

# 최적의 코딩을 결정하는 알고리즘

>  총 25차시 - 온라인 강의 요약



## 1. 스택과 큐

## 스택

- 삽입과 삭제로 구성

- 가장 먼저 들어간 원소가 나중에 나오는 형태(선입후출)
- Python 에서는 리스트 구조가 스택에 해당됨



## 큐

- 먼저 들어온 데이터가 먼저 나가는 형식(선입선출)
- python 에서는 `from collections import duque`

```python
from collections import deque

# 역순으로 바꾸기
queue.reverse()
```



## 2. 우선순위 큐

- 데이터를 우선순위에 따라 처리하고 싶을 때 사용

- 구현방법

  - 리스트를 이용해서 구현
  - 힙(heap)을 이용해서 구현

  | 우선순위 큐 구현 방식 | 삽입 시간 | 삭제 시간 |
  | --------------------- | --------- | --------- |
  | 리스트                | O(1)      | O(N)      |
  | 힙(Heap)              | O(*logN*) | O(*logN*) |

- 단순히 N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일하다.(힙 정렬)

  - 시간 복잡도는 O(*logN*)



비교

| 자료 구조                   | 추출되는 데이터             |
| --------------------------- | --------------------------- |
| 스택(Stack)                 | 가장 나중에 삽입된 데이터   |
| 큐(Queue)                   | 가장 먼저 삽입된 데이터     |
| 우선순위 큐(Priority Queue) | 가장 우선순위가 높은 데이터 |



### 힙의 특징

- 힙은 **완전 이진 트리 자료구조**의 일종이다.
- 힙에서는 항상 루트 노드(root node)를 제거한다.
- **최소 힙(min heap)**
  - 루트 노드가 가장 작은 값을 가진다.
  - 따라서 값이 작은 데이터가 우선적으로 제거 된다.
- **최대 힙(max heap)**
  - 루트 노드가 가장 큰 값을 가진다.
  - 따라서 값이 가장 큰 데이터가 우선적으로 제거된다.





#### 완전 이진 트리(Complete Binary Tree)

- 루트 노드부터 시작하여 왼쪽 자식 노드, 오른쪽 자식 노드 순서대로 데이터가 차례대로 삽입되는 트리

- 최소 힙 구성 합수 : Min - Heapify()

  - (상향식) 부모 노드로 거슬러 올라가며, 부모보다 자신의 값이 더 작은 경우에 위치를 교체한다.
  - 새로운 원소가 삽입되었을 때 O(*logN*)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있다.

  ![](/Users/kimsinwoo/Downloads/최소 힙 구성함수.png)

  - 원소가 제거되었을 때 O(*logN*)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있다.

    - 이후에 루트 노드에서부터 하향식으로(더 작은 자식 노드로) Heapify()를 진행한다.

      ![](/Users/kimsinwoo/Downloads/원소 제거 - 힙라이브러ㄹ;.png)



- 힙 정렬 구현 예제

```python
# 파이썬에서는 min - heap 이 기본값
# max 로 구현하고 싶다면 - 값으로 출력하면 된다.

import sys
import heapq

input = sys.stdin.readline

def heapsort(iterable):
	h = []
	result = []
	# 모든 원소를 차례대로 꺼내어 담기
	for value in itrable:
		heapq.heappush(h,value)
	return result
	
n = int(input())
arr = []

for i in range(n):
	arr.append(int(input()))
	
res = heapsort(arr)

for i in range(n):
	print(res[i])
```



## 3. 트리자료구조

### 트리

- 가계도와 같은 계층적인 구조로 표현할 떄 사용할 수 있는 자료구조입니다.
- 기본적으로 트리의 크기가 N일 때, 전체 간선의 개수는 N - 1개이다.



**트리 관련 용어**

- 루트 노드 : 부모가 없는 최상위 노드
- 단말 노드 : 자식이 없는 노드
- 크기 : 트리에 포함된 모든 노드의 개수
- 깊이 : 루트 노드로부터의 거리
- 높이: 깊이 중 최댓값
- 차수 : 각 노드의 자식방향 간선 개수(자식이 몇 개인지)



### 이진 탐색 트리

- 이진 탐색이 동장할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조의 일종이다.
- 이진 탐색 트리의 특징 : 왼쪽 자식 노드 < 부모 노드 > 오른쪽 자식 노드
- 값을 찾는 방법
  - 1. 루트 노드부터 방문하여 탐색을 진행



![](/Users/kimsinwoo/Downloads/이진탐색 트리.png)



### 트리의 순회(Tree Traversal)

- 트리 자료구조에 포함된 노드를 특정한 방법으로 한번씩 방문
  - 전위 순회 : 루트를 먼저 방문 ( 30 > 17 > 5 > 23 > 48 > 37 > 50)
  - 중위 순회 : 왼쪽 자식을 방문한 뒤에 루트를 방문 (5 >17 > 23 > 30 > 37 > 48 > 50 )
  - 후위 순회 : 오른쪽 자식을 방문한 뒤에 루트를 방문 (5  > 23 > 17 > 37 >  50 > 48)





## 4. 바이너리 인덱스 트리(BIT)

- 2진법 인덱스 구조를 활용해 구간 합 문제를 효과적으로 해결해 줄 수 있는 자료구조

- 펜윅 트리(Fenwick tree)

- 0이 아닌 마지막 비트를 찾는 방법 : K & -K 계산

  - ```python
    n = 8
    
    for i in range(n+1):
    	print(i, "의 마지막 비으 :".(i & -i))
    ```

  - <img src="/Users/kimsinwoo/Downloads/BIT.png" style="zoom:50%;" />

- 트리 구조 만들기 : 0이 아닌 마지막 비트 = 내가 저장하고 있는 값들의 개수

  ![](/Users/kimsinwoo/Downloads/트리구조.png)

- 특정 값을 변경할 때 : 0이 아닌 마지막 비트만큼 더하면서 구간들의 값을 변경 ( 예시 = 3rd)

![](/Users/kimsinwoo/Downloads/특정 값을 바꿀때.png)



- 1부터 N까지의 합 구하기 : 0이 아닌 마지막 비트만큼 빼면서 구간들의 값의 합 계산

![](/Users/kimsinwoo/Downloads/구간 합.png)



## 5. 정렬 알고리즘

> 데이터 요소들을 특정한 순서대로 재배치 하는 방법을 다루는 중요한 주제이다.

- **정렬(Sorting)** : 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말합니다.
- 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용된다.



### 선택 정렬(Selection Sort)

- 처리되지 않은 데이터 중에서 가장 작은 데이터를 선책해 맨 앞에 있는 데이터와 바꾸는 것을 반복한다.

- 선택 정렬은 N번만큼 반복해야 한다.

```python
array = [7,4,5,9,1,2,3]

for i in range(len(array)):
	min_index = i # 가장 작은 원소의 인덱스
	for j in range(i+1,len(array)):
		if array[min_index] > array[j]:
			min_index = j
	array[i], array[min_index] = array[min_index],array[i] # 스와프
	
print(array)
```



### 삽입 정렬(Insertion Sort)

- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입합니다.
- 선택 정렬에 비해 더 빠르게 정렬, 현재 리스트의 데이터가 거의 정렬되어 잇는 상태라면 매우 빠르게 동작한다.
- 첫번째 데이터는 그 자체로 정렬 되어 있다고 판단하고 두번째 데이터가 첫번째 데이터의 왼쪽으로 들어갈지 오른쪽으로 들어갈지 판단한다. (매번 위치를 바꿔가면서 정렬)



```python
array = [7,4,5,9,1,2,3]

for i in range(1, len(array)):
	 for j in range(i, 0, -1): # 인덱스 i 부터 1까지 1씩 감소하며 반복하는 문법
	 	if array[j] < array[j - 1] # 한칸씩 왼쪽으로 이동
	 		array[j], array[j -1] = array[j - 1],array[j]
	 	else: # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
	 		break

point(array)
	 	
```



### 퀵 정렬

- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법이다.
- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나이다.
- 첫번째 데이터를 기본 데이터(Pivot)로 설정한다.





### 계수 정렬

- 특정한 조건일때만 동작하지만, 매우 빠르게 동작한다.
- 때에 따라서 심각한 비효율성을 초래할 수 있다.





### 정렬 알고리즘 비교하기

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                  |
| ------------- | ---------------- | ----------- | ----------------------------------------------------- |
| 선택 정렬     |                  |             | 아이디어가 매우 간단하다.                             |
| 삽입 정렬     |                  |             | 데이터가 거의 정렬되어 있을 대는 가장 빠르다.         |
| 퀵 정렬       |                  |             | 대부분의 경우에 가장 적합하며, 충분히 빠르다.         |
| 계수 정렬     |                  |             | 데이터의 크기가 한정되어 있는 경우에만 사용 가능하다. |

