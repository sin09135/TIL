## SQL 최적화 기본 원리

- 주요 내용
  - 옵티마이저와 실행 계획
    - 규칙기반 옵티마이저
    - 비용기반 옵티마이저
  - 인덱스 기본
    - B-Tree 인덱스
    - Index Scan/Full Scan
  - 조인 수행 원리(어떻게 찾을건데?)
    - NL Join
    - Sort Merge Join
    - Hash Join



## 옵티마이저

### 옵티마이저 개념

- SQL 은 사용자의 요구사항만 기술할 뿐 처리 과정은 기술하지 않음
  - 실제로 SQL 문을 실행하기 전에 최적의 실행계획을 찾아야 함
- 옵티마이저 : 사용자의 요구사항을 만족하는 다양한 실행계획 중 최적의 실행계획을 결정
  - SQL 을 어떤 순서로 어떻게 실행할지 결정하는 작업 수행



### 옵티마이저 종류

- 규칙 기반 옵티마이저(RBO : Rule Based Optimizer)
  - 거의 사용하지 않지만, 하위 버전의 호환성을 위해 유지
  - 1~14 : Index Scan
  - 15~ : Full Scan
  - 규칙1. Single row by Rowid
    - Rowed 를 통해서 테이블에서 하나의 행을 엑세스
  - 규칙4. Single row by unique or primary key
    - Unique Index 를 통해서 하나의 행을 액세스하는 방식
    - 인덱스를 먼저 액세스하고 인덱스의 Rowid를 추출하여 행을 액세스
  - 규칙8. Composite index
    - 복합 인덱스로 검색하는 경우
    - 복합 인덱스 사이의 우선 순위 규칙
      - 인덱스 매칭률이 높을수록 우선
        - 인덱스 매칭률 : 사용되는 컬럼 중 얼마나 매칭조건으로 사용되냐
          - 인덱스 순서대로 계산
      - 인덱스 매칭률이 동일하면, 구성 칼럼이 많을수록 우선
      - 3개짜리 조합과 2개짜리 조합이면, 3개짜리 조합이 우선
  - 규칙 9. Single columns index
    - 단일 컬럼 인덱스에 '=' 조건으로 검색
  - 규칙10. Bounded range search on indexed columns
    - 인덱스가 생성되어 잇는 컬럼에 양쪽 범위를 한정하는 형태로 검색
  - 규칙11. Unbounded range search on indexed columns
    - 인덱스가 생성되어있는 컬럼에 한쪽 범위만 한정하는 형태로 검색
      - '>,>=, <,<='
  - 규칙15. Full table Scan
    - 일반적으로 속도가 느리지만 병렬 처리 가능



- 비용 기반 옵티마이저(CBO: Cost-Based Optimizer) - **cost 란 말이 곳곳에 나옴**

  ![옵티마이저 동작구조](/Users/kimsinwoo/Downloads/비용기반 옵티마이저.png)

  - 몇개의 규칙만으로 현실의 모든 상황을 설명하기 어려움
  - SQL문 처리에 예상되는 비용을 최소화하기 위한 방법 필요
  - 테이블, 인덱스, 컬럼 등의 객체에 대한 통계정보, 시스템 통계정보 활용
    - 정확한 통계정보 관리는 비용기반 최적화의 중요한 요소임
  - 통계정보, DBMS버전, DBMS 설정 정보에 따라 동일한 SQL문도 서로 다른 실행계획이 생성될 수 있음

  - 질의 변환기

  - 대안 계획 생성기
    - 가능한 모든 계획을 생성하지는 않으므로, 최적 대안이 누락되는 경우도 있음
  - 비용 에측기
    - 다양한 통계정보를 활용



### 비용기반 옵티마이저 실행 계획

- 최적화 정보는 실제 실행 결과가 아닌 통계 정보 바탕의 **예측치**

  - Cost : 상대적인 비용 정보(숫자가 낮을수록 유리)
  - Card : 주어진 조건을 만족하는 행의 수
  - Bytes : 결과집합이 차지하는 메모리의 양

  => **3개가 전부 작아야 유리**



#### Full Table Scan 하는 경우

- Sql 문에 조건이 존재하지 않는 경우 > 모든 데이터가 답
- Sql 문 조건에 사용 가능한 인덱스가 없는 경우
- 조건을 만족하는 데이터가 매우 많은 경우
- 병렬 처리방식으로 처리하는 경우





### 옵티마이저 동작 구조

![옵티마이저 동작구조](/Users/kimsinwoo/Downloads/옵티마이저 동작구조.png)



### 인덱스(Index)

- 검색 속도의 향상을 위한 기술
  - 지나치게 많은 인덱스 생성시 시간 및 공간 낭비
  - 인덱스된 필드의 업데이트시 시간 증가
- B-트리 인덱스가 가장 보편적
  - **일치 검색과 범위 검색에 모두 적합**
- 유형
  - 인덱스 유일 스캔
    - unique index 를 사용하여 단 하나의 데이터를 추출
    - 인덱스 구성 칼럼에 조건이 모두 = 로 주어진 경우
  - 인덱스 범위 스캔
    - 한 건 이상의 데이터를 추출하는 방힉
    - Non - Unique Index 를 이용하는 경우
    - Index 구성 컬럼에 = 이외의 조건이 주어진 경우



### B - 트리 인덱스

![B 트리 인덱스](/Users/kimsinwoo/Downloads/B 트리 인덱스.png)



## 조인 기법

### NL 조인(소규모에 유리)

- 선행 테이블(외부 테이블)과 후행 테이블(내부 테이블) 조인
- 선행 테이블의 조건을 만족하는 행 추출 > 후행 테이블 읽으면서 조인
  - 이 과정을 선행테이블의 조건을 만족하는 행 수만큼 반복
- 결과 행의 수가 적은 테이블을 조인 순서상 선행테이블로 두는 것이 유리함



### Sort Merge 조인

![sortmerge](/Users/kimsinwoo/Downloads/sortmerge.png)

- 조인 컬럼 기준으로 데이터를 정렬한 후 조인 수행
- 정렬할 데이터가 많은 경우에는 성능 저하
- **Non equi 조인 가능**



### Hash join 

- 조인 컬럼 기준으로 해쉬 함수를 수행하여 동일한 해쉬 값을 갖는 경우에만 실제 값을 비교하여 조인 수행
- 데이터가 많은 경우 유리
- 해시 테이블을 메모리에 생성해야 함
  - 결과 행의 수가 적은 테이블을 선행테이블(Build input,)로 사용하는 것이 좋음
  - Build input, Probe input



![조인요약](/Users/kimsinwoo/Downloads/조인요약.png)